use crate::errors::ApicentricResult;
use crate::simulator::config::{EndpointDefinition, EndpointKind, ServiceDefinition};
use crate::simulator::typescript::to_typescript;

/// Generate an Axios client for a service definition.
pub fn generate_axios_client(service: &ServiceDefinition) -> ApicentricResult<String> {
    let mut out = String::new();
    out.push_str("// Generated by Apicentric\n");
    out.push_str(
        "import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';\n\n",
    );

    // Add types
    out.push_str(&to_typescript(service)?);
    out.push_str("\n\n");

    let class_name = format!("{}Client", service.name.replace(' ', ""));
    out.push_str(&format!("export class {} {{\n", class_name));
    out.push_str("    private client: AxiosInstance;\n\n");
    out.push_str("    constructor(config: AxiosRequestConfig) {\n");
    out.push_str("        this.client = axios.create(config);\n");
    out.push_str("    }\n\n");

    let endpoints = service.endpoints.as_ref().cloned().unwrap_or_default();

    // Fix: base_path is String, not Option<String> in ServerConfig
    let base_path = if let Some(server) = &service.server {
        server.base_path.clone()
    } else {
        "/".to_string()
    };

    for ep in &endpoints {
        if ep.kind != EndpointKind::Http {
            continue;
        }
        out.push_str(&generate_endpoint_method(ep, &base_path));
        out.push('\n');
    }

    out.push_str("}\n");
    Ok(out)
}

fn generate_endpoint_method(ep: &EndpointDefinition, base_path: &str) -> String {
    let method_name = method_name(ep);
    let params = path_params(&ep.path);
    let param_list = format_params(&params, ep.method != "GET");
    let url = build_url(base_path, &ep.path, &params);
    let http_method = ep.method.to_lowercase();

    // Fix: unused variable removed
    let request_args = if ep.method != "GET" {
        "url, data".to_string()
    } else {
        "url".to_string()
    };

    // Construct the method signature and body
    let mut code = String::new();

    // JSDoc
    code.push_str(&format!(
        "    /**\n     * {} {}\n     */\n",
        ep.method, ep.path
    ));

    // Method signature
    code.push_str(&format!(
        "    async {}({}): Promise<AxiosResponse<any>> {{\n",
        method_name, param_list
    ));

    // URL construction
    code.push_str(&format!("        const url = `{}`;\n", url));

    // Request call
    code.push_str(&format!(
        "        return this.client.{}({});\n",
        http_method, request_args
    ));

    code.push_str("    }\n");
    code
}

fn method_name(ep: &EndpointDefinition) -> String {
    let path_part = ep
        .path
        .trim_matches('/')
        .split('/')
        .filter(|s| !s.is_empty())
        .map(|s| s.trim_matches(|c| c == '{' || c == '}'))
        .map(capitalize)
        .collect::<String>();

    let prefix = ep.method.to_lowercase();
    format!("{}{}", prefix, path_part)
}

fn path_params(path: &str) -> Vec<String> {
    path.split('/')
        .filter_map(|seg| {
            if seg.starts_with('{') && seg.ends_with('}') {
                Some(seg[1..seg.len() - 1].to_string())
            } else {
                None
            }
        })
        .collect()
}

fn format_params(params: &[String], has_body: bool) -> String {
    let mut args = Vec::new();
    for p in params {
        args.push(format!("{}: string", p));
    }
    if has_body {
        args.push("data: any".to_string());
    }
    // Add config last
    args.push("config?: AxiosRequestConfig".to_string());
    args.join(", ")
}

fn build_url(base_path: &str, path: &str, params: &[String]) -> String {
    let mut full = format!(
        "{}/{}",
        base_path.trim_end_matches('/'),
        path.trim_start_matches('/')
    );
    for p in params {
        full = full.replace(&format!("{{{}}}", p), &format!("${{{}}}", p));
    }
    full
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
        None => String::new(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::simulator::config::ServerConfig;

    #[test]
    fn generates_axios_client_methods() {
        let service = ServiceDefinition {
            name: "TestService".into(),
            version: None,
            description: None,
            server: Some(ServerConfig {
                port: None,
                base_path: "/api".into(),
                proxy_base_url: None,
                cors: None,
                record_unknown: false,
            }),
            models: None,
            fixtures: None,
            bucket: None,
            endpoints: Some(vec![
                EndpointDefinition {
                    kind: EndpointKind::Http,
                    method: "GET".into(),
                    path: "/users/{id}".into(),
                    header_match: None,
                    description: None,
                    parameters: None,
                    request_body: None,
                    responses: Default::default(),
                    scenarios: None,
                    stream: None,
                },
                EndpointDefinition {
                    kind: EndpointKind::Http,
                    method: "POST".into(),
                    path: "/users".into(),
                    header_match: None,
                    description: None,
                    parameters: None,
                    request_body: None,
                    responses: Default::default(),
                    scenarios: None,
                    stream: None,
                },
            ]),
            graphql: None,
            behavior: None,
            #[cfg(feature = "iot")]
            twin: None,
        };

        let client = generate_axios_client(&service).unwrap();

        assert!(client.contains("class TestServiceClient"));
        assert!(client.contains("async getUsersId(id: string, config?: AxiosRequestConfig)"));
        // Check for proper interpolation
        assert!(client.contains("const url = `/api/users/${id}`"));
        assert!(client.contains("async postUsers(data: any, config?: AxiosRequestConfig)"));
    }
}
