use crate::errors::ApicentricResult;
use crate::simulator::config::{EndpointDefinition, EndpointKind, ServiceDefinition};
use crate::simulator::react_query::generate_react_query_hooks;

/// Generate a React component view for a service definition.
pub fn generate_react_view(service: &ServiceDefinition) -> ApicentricResult<String> {
    // Generate hooks first (and ensure it works)
    let _ = generate_react_query_hooks(service)?;

    let mut out = String::new();
    out.push_str("// Generated by Apicentric\n");
    out.push_str("import React from 'react';\n");
    out.push_str("import { Card, Table, Button, Form, Input, Space, Tag } from 'antd';\n");
    out.push_str("import { useQueryClient } from '@tanstack/react-query';\n");
    out.push_str("// Import generated hooks\n");

    let endpoints = service.endpoints.as_ref().cloned().unwrap_or_default();
    let http_endpoints: Vec<&EndpointDefinition> = endpoints
        .iter()
        .filter(|ep| ep.kind == EndpointKind::Http)
        .collect();

    // Imports
    out.push_str("import {\n");
    for ep in &http_endpoints {
        let hook = hook_name(ep);
        out.push_str(&format!("    {},\n", hook));
    }
    out.push_str("} from './hooks';\n\n");

    let component_name = format!("{}View", service.name.replace(' ', ""));
    out.push_str(&format!(
        "export const {}: React.FC = () => {{\n",
        component_name
    ));
    out.push_str("    const queryClient = useQueryClient();\n\n");

    // Form instances for mutations
    for (i, ep) in http_endpoints.iter().enumerate() {
        if ep.method != "GET" {
            out.push_str(&format!("    const [form{}] = Form.useForm();\n", i));
        }
    }
    out.push('\n');

    // Hook calls
    for (i, ep) in http_endpoints.iter().enumerate() {
        let hook = hook_name(ep);
        if ep.method == "GET" {
            // Assume no params for simple view, or pass empty/defaults
            // This is a simplification for the view generator
            out.push_str(&format!(
                "    const {{ data: data{}, isLoading: isLoading{}, error: error{} }} = {}('');\n",
                i, i, i, hook
            ));
        } else {
            out.push_str(&format!(
                "    const {{ mutate: mutate{}, isPending: isPending{} }} = {}('');\n",
                i, i, hook
            ));
        }
    }
    out.push('\n');

    // Render
    out.push_str("    return (\n");
    out.push_str("        <Space direction=\"vertical\" style={{ width: '100%' }}>\n");
    out.push_str(&format!(
        "            <Card title=\"{} Management\">\n",
        service.name
    ));

    for (i, ep) in http_endpoints.iter().enumerate() {
        out.push_str(&format!(
            "                <Card type=\"inner\" title=\"{} {}\">\n",
            ep.method, ep.path
        ));

        if ep.method == "GET" {
            out.push_str(&format!("                    {{isLoading{} ? (\n", i));
            out.push_str("                        <p>Loading...</p>\n");
            out.push_str(&format!("                    ) : error{} ? (\n", i));
            out.push_str(&format!(
                "                        <p>Error: {{(error{} as any).message}}</p>\n",
                i
            ));
            out.push_str("                    ) : (\n");
            out.push_str("                        <Table\n");
            out.push_str(&format!("                            dataSource={{Array.isArray(data{}) ? data{} : [data{}]}}\n", i, i, i));
            out.push_str("                            columns={[\n");
            out.push_str("                                { title: 'Data', dataIndex: 'id', key: 'id', render: (val: any, record: any) => JSON.stringify(record) }\n");
            out.push_str("                            ]}\n");
            out.push_str("                            rowKey=\"id\"\n");
            out.push_str("                        />\n");
            out.push_str("                    )}\n");
        } else {
            out.push_str("                    <Form\n");
            out.push_str(&format!("                        form={{form{}}}\n", i));
            out.push_str("                        layout=\"inline\"\n");
            out.push_str("                        onFinish={(values) => {\n");
            out.push_str(&format!(
                "                            mutate{}(values, {{\n",
                i
            ));
            out.push_str("                                onSuccess: () => {\n");
            out.push_str("                                    queryClient.invalidateQueries();\n");
            out.push_str(&format!(
                "                                    form{}.resetFields();\n",
                i
            ));
            out.push_str("                                }\n");
            out.push_str("                            });\n");
            out.push_str("                        }}\n");
            out.push_str("                    >\n");
            out.push_str("                        <Form.Item name=\"payload\">\n");
            out.push_str(
                "                            <Input.TextArea placeholder=\"JSON Payload\" />\n",
            );
            out.push_str("                        </Form.Item>\n");
            out.push_str("                        <Form.Item>\n");
            out.push_str(&format!("                            <Button type=\"primary\" htmlType=\"submit\" loading={{isPending{}}}>\n", i));
            out.push_str("                                Execute\n");
            out.push_str("                            </Button>\n");
            out.push_str("                        </Form.Item>\n");
            out.push_str("                    </Form>\n");
        }

        out.push_str("                </Card>\n");
    }

    out.push_str("            </Card>\n");
    out.push_str("        </Space>\n");
    out.push_str("    );\n");
    out.push_str("};\n");

    Ok(out)
}

fn hook_name(ep: &EndpointDefinition) -> String {
    // Duplicate logic from react_query.rs to ensure matching imports
    // Ideally this should be shared or imported from react_query if pub
    let path_part = ep
        .path
        .trim_matches('/')
        .split('/')
        .filter(|s| !s.is_empty())
        .map(|s| s.trim_matches(|c| c == '{' || c == '}'))
        .map(capitalize)
        .collect::<String>();

    if ep.method == "GET" {
        format!("use{path_part}Query")
    } else {
        let method = capitalize(&ep.method.to_lowercase());
        format!("use{method}{path_part}Mutation")
    }
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
        None => String::new(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::simulator::config::ServerConfig;

    #[test]
    fn generates_view_component() {
        let service = ServiceDefinition {
            name: "TestService".into(),
            version: None,
            description: None,
            server: Some(ServerConfig {
                port: None,
                base_path: "/api".into(),
                proxy_base_url: None,
                cors: None,
                record_unknown: false,
            }),
            models: None,
            fixtures: None,
            bucket: None,
            endpoints: Some(vec![
                EndpointDefinition {
                    kind: EndpointKind::Http,
                    method: "GET".into(),
                    path: "/users".into(),
                    header_match: None,
                    description: None,
                    parameters: None,
                    request_body: None,
                    responses: Default::default(),
                    scenarios: None,
                    stream: None,
                },
                EndpointDefinition {
                    kind: EndpointKind::Http,
                    method: "POST".into(),
                    path: "/users".into(),
                    header_match: None,
                    description: None,
                    parameters: None,
                    request_body: None,
                    responses: Default::default(),
                    scenarios: None,
                    stream: None,
                },
            ]),
            graphql: None,
            behavior: None,
            #[cfg(feature = "iot")]
            twin: None,
        };

        // We can't easily mock generate_react_query_hooks without trait abstraction or strict mocking
        // But for this unit test, if generate_react_query_hooks depends on external tools (npx),
        // we might fail.
        // However, generate_react_view calls it just to check error.
        // If we want a pure logic test, we should mock or separate the logic.
        // For now, assuming environment has npx or accepting integration nature.
        // Actually, generate_react_query_hooks calls to_typescript which calls npx.

        let view = generate_react_view(&service).unwrap();

        assert!(view.contains("export const TestServiceView"));
        assert!(view.contains("useUsersQuery"));
        assert!(view.contains("usePostUsersMutation"));
        assert!(view.contains("<Table"));
        assert!(view.contains("<Form"));
    }
}
